import os
import uuid


pepfile: "pep/config.yaml"
pepschema: "workflow/schemas/manifest_schema.yaml"

samples = pep.sample_table

# print(samples)
# print(pep.config.output_dir)

# get unique value of a list
# print(list(set(samples["FLOWCELL"].tolist())))

flowcells = list(set(samples["FLOWCELL"].tolist()))
subjs = list(set(samples["SAMPLEID"].tolist()))

subj_flowcell_dict=samples[['SAMPLEID','FLOWCELL']].drop_duplicates().groupby('SAMPLEID')['FLOWCELL'].apply(list).to_dict()

ref_dict=os.path.splitext(pep.config.hg38_ref)[0]+'.dict'



def get_bam(wildcards):
    # ../bam/AH8VC6ADXX/HG002_NA24385_son_2A1_L1.bam
    df=samples.loc[samples['FLOWCELL'] == wildcards.flowcell]
    bam_files=[ "%s/%s/%s.bam" % (pep.config.input_bam_dir,row['FLOWCELL'], row['bam_name']) for index,row in df.iterrows()]
    return bam_files


### Take bam files from fq2bam folder

def get_fq2bam(wildcards):
    # ../bam/AH8VC6ADXX/HG002_NA24385_son_2A1_L1.bam
    df=samples.loc[samples['FLOWCELL'] == wildcards.flowcell]
    bam_files=[ "%s/%s/%s.bam" % (pep.config.output_dir + "/fq2bam",row['FLOWCELL'], row['bam_name']) for index,row in df.iterrows()]
    return bam_files

def get_bam_by_subj(wildcards):
    flowcells=subj_flowcell_dict[wildcards.subj]
    return expand(pep.config.output_dir +"/gatk_markdup/{flowcell}.dedup.bam", flowcell=flowcells)

### Use the bam files directly from merge_by_flowcell_pb
# merged.bam
def get_bam_by_subj_pb(wildcards):
    flowcells=subj_flowcell_dict[wildcards.subj]
    return expand(pep.config.output_dir +"/merge_by_flowcell_pb/{flowcell}.merged.bam", flowcell=flowcells)

COVERAGES=[5,30,80]

trio_dict = {
    "trio":{
        "child": "HG002_NA24385_son",
        "father": "HG003_NA24149_father",
        "mother": "HG004_NA24143_mother" 
    }
}


TRIOS=list(trio_dict.keys())
TRIO_MEMBERS=["child", "father", "mother"]

def get_trio_hc_gvcf(wildcards):
    rv = {
        "child": pep.config.output_dir +"/gatk_hc2/"+trio_dict[wildcards.trio]["child"]+"_" + str(wildcards.cov) + ".gatk.g.vcf",
        "mother": pep.config.output_dir +"/gatk_hc2/"+trio_dict[wildcards.trio]["mother"]+"_" + str(wildcards.cov) + ".gatk.g.vcf",
        "father": pep.config.output_dir +"/gatk_hc2/"+trio_dict[wildcards.trio]["father"]+"_" + str(wildcards.cov) + ".gatk.g.vcf",
        "ref": pep.config.hg38_ref
    }
    return rv

def get_trio_hc_gvcf_pb(wildcards):
    rv = {
        "child": pep.config.pb_output_dir +"/gatkhc_pb/"+trio_dict[wildcards.trio]["child"]+"_" + str(wildcards.cov) + ".gatk.g.vcf",
        "mother": pep.config.pb_output_dir +"/gatkhc_pb/"+trio_dict[wildcards.trio]["mother"]+"_" + str(wildcards.cov) + ".gatk.g.vcf",
        "father": pep.config.pb_output_dir +"/gatkhc_pb/"+trio_dict[wildcards.trio]["father"]+"_" + str(wildcards.cov) + ".gatk.g.vcf",
        "ref": pep.config.hg38_ref
    }
    return rv

def get_trio_hc_gvcf_dv(wildcards):
    rv = {
        "child": pep.config.pb_output_dir +"/deepvariant_pb/"+trio_dict[wildcards.trio]["child"]+"_" + str(wildcards.cov) + "X.deepvariant.g.vcf",
        "mother": pep.config.pb_output_dir +"/deepvariant_pb/"+trio_dict[wildcards.trio]["mother"]+"_" + str(wildcards.cov) + "X.deepvariant.g.vcf",
        "father": pep.config.pb_output_dir +"/deepvariant_pb/"+trio_dict[wildcards.trio]["father"]+"_" + str(wildcards.cov) + "X.deepvariant.g.vcf",
        "ref": pep.config.hg38_ref
    }
    return rv

def get_trio_bam(wildcards):
    # pep.config.output_dir+"downsample_bam/"+trio_dict[{trio}]["child"]+"_{cov}X.bam"
    rv = { key: pep.config.output_dir+"/downsample_bam/%s_%sX.bam" % (trio_dict[wildcards.trio][key], wildcards.cov) for key in TRIO_MEMBERS}

    return rv

# print(subj_flowcell_dict)

rule all:
    input: 
        expand(pep.config.output_dir +"/merge_by_flowcell_pb/{flowcell}.merged.bam", flowcell=flowcells),
        expand(pep.config.pb_output_dir +"/downsample_bam/{subj}_{cov}X.bam", subj=subjs, cov=COVERAGES),
        expand(pep.config.pb_output_dir +"/collectmultiplemetrics/{subj}_{cov}X/sequencingArtifact.pre_adapter_summary_metrics.txt", subj=subjs, cov=COVERAGES),
        # expand(pep.config.pb_output_dir +"/gatkhc_pb/{subj}_{cov}.gatk.g.vcf", subj=subjs, cov=COVERAGES),
        expand(pep.config.pb_output_dir+"/gatk_cgp/{trio}_{cov}X.cgp.g.vcf.gz", trio=TRIOS, cov=COVERAGES),
        expand(pep.config.pb_output_dir +"/glnexus/{trio}_{cov}X.dv_combined.vcf.gz", trio=TRIOS, cov=COVERAGES),
        expand(pep.config.pb_output_dir +"/hap.py/{caller}_{trio}_{cov}X.happy.extended.csv", cov=COVERAGES, trio=TRIOS, caller=["GATK", "DV"] )


# ./HG002_NA24385_son/NIST_HiSeq_HG002_Homogeneity-10953946/HG002_HiSeq300x_fastq/140528_D00360_0018_AH8VC6ADXX/Project_RM8391_RM8392/Sample_2A1/2A1_CGATGT_L001_R1.fq.gz
rule fastp: 
    input: 
        R1= lambda w:  pep.config.input_fq_dir + "/%s" % samples.loc[w.flowcell+'_'+w.bam]["R1"],
        R2= lambda w:  pep.config.input_fq_dir + "/%s" % samples.loc[w.flowcell+'_'+w.bam]["R2"]
    output: 
        R1=pep.config.output_dir+"/fastp/{flowcell}/{bam}.R1.fastp.fastq.gz",
        R2=pep.config.output_dir+"/fastp/{flowcell}/{bam}.R2.fastp.fastq.gz",
        html=pep.config.output_dir+"/fastp/{flowcell}/{bam}.html",
        json=pep.config.output_dir+"/fastp/{flowcell}/{bam}.json"
    benchmark:
        pep.config.output_dir + "/benchmark/fastp/{flowcell}_{bam}.tsv"
    threads: 8
    resources:
        mem_mb=40000,
        runtime=600
    envmodules: "fastp"
    shell: """
        fastp \
                --in1 {input.R1} \
                --in2 {input.R2} \
                --out1 {output.R1} \
                --out2 {output.R2} \
                --report_title {wildcards.bam} \
                --json {output.json} \
                --html {output.html} \
                --thread {threads} \
                --qualified_quality_phred 25 --n_base_limit 10 --average_qual 25 \
                --length_required 50 --low_complexity_filter
    """

# https://docs.nvidia.com/clara/parabricks/4.0.1/documentation/tooldocs/man_fq2bam.html#man-fq2bam
rule fq2bam:
    input: 
        R1=pep.config.output_dir+"/fastp/{flowcell}/{bam}.R1.fastp.fastq.gz",
        R2=pep.config.output_dir+"/fastp/{flowcell}/{bam}.R2.fastp.fastq.gz",
        ref=pep.config.hg38_ref
    output: pep.config.output_dir + "/fq2bam/{flowcell}/{bam}.bam"
    params: RG=lambda w: "'@RG\\tPL:ILLUMINA\\tID:{FLOWCELL}.{LANE}\\tSM:{SAMPLEID}\\tPU:{FLOWCELL}.{LANE}.{INDEX}\\tLB:{SAMPLEID}_{INDEX}'" .format (**samples.loc[w.flowcell+'_'+w.bam])
    benchmark: 
        pep.config.output_dir + "/benchmark/fq2bwa/{flowcell}_{bam}.tsv"
    resources: 
        threads=48,
        mem_mb = 360000,
        runtime= "1d",
        partition="gpu",
        slurm="gres=gpu:v100x:4",
        tmpdir=pep.config.output_dir + "/TMP"
    envmodules: "parabricks/4.0.0"
    shell: """
        pbrun fq2bam \
            --ref {input.ref} \
            --in-fq {input.R1} {input.R2}  {params.RG} \
            --out-bam {output} 
    """


rule merge_bam_by_flowcell_pb: 
    input: get_fq2bam
    output: 
        bam=pep.config.output_dir +"/merge_by_flowcell_pb/{flowcell}.merged.bam",
        bai=pep.config.output_dir +"/merge_by_flowcell_pb/{flowcell}.merged.bam.bai"
    threads: 16
    resources :
        mem_mb=40000,
        runtime=600
    envmodules: "samtools"
    benchmark: 
        pep.config.output_dir + "/benchmark/merge_bam_by_flowcell_pb/{flowcell}.tsv"
    shell: """
        samtools merge --threads {threads} {output.bam} {input}
        samtools index {output.bam}
    """

### Direct results to pb_output_dir instead
# output_dir: "giab_output"
# pb_output_dir: "giab_output_pb"

rule merge_bam_by_subj: 
    input: get_bam_by_subj_pb
    output: 
        bam=pep.config.pb_output_dir +"/merge_by_subj/{subj}.merged.bam",
        bai=pep.config.pb_output_dir +"/merge_by_subj/{subj}.merged.bam.bai"
    threads: 16
    resources :
        mem_mb=80000,
        runtime=2880
    envmodules: "samtools"
    shell: """
        samtools merge --threads {threads} {output.bam} {input}
        samtools index {output.bam}
    """

### downsample first
# rule final_stats: 
#     input: pep.config.pb_output_dir +"/merge_by_subj/{subj}.merged.bam"
#     output: pep.config.pb_output_dir +"/final_bam_metrics/{subj}.stats"
#     threads: 16
#     resources :
#         mem_mb=80000,
#         runtime=600
#     envmodules: "samtools"
#     shell: """
#         samtools stats -@ {threads} {input} > {output}
#     """

rule final_flagstats: 
    input: pep.config.pb_output_dir +"/merge_by_subj/{subj}.merged.bam"
    output: 
        flagstat=pep.config.pb_output_dir +"/final_bam_metrics/{subj}.flagstat",
        idxstats=pep.config.pb_output_dir +"/final_bam_metrics/{subj}.idxstats"
    threads: 16
    resources :
        mem_mb=80000,
        runtime=600
    envmodules: "samtools"
    shell: """
        samtools flagstat -@ {threads} {input} > {output.flagstat}
        samtools idxstat {input} > {output.idxstats}
    """

rule calc_frac:
    input: 
        idxstats=pep.config.pb_output_dir +"/final_bam_metrics/{subj}.idxstats"
    output: 
        frac=pep.config.pb_output_dir +"/downsample_bam/{subj}_{cov}X.fract"
    shell: """
        x=$(cut -f 3 {input} | paste -sd+ | bc); echo "scale=4;3.3*10^9 * {wildcards.cov}/148/$x" | bc > {output} 
    """

rule downsample_bam: 
    input: 
        fract=pep.config.pb_output_dir +"/downsample_bam/{subj}_{cov}X.fract",
        bam=pep.config.pb_output_dir +"/merge_by_subj/{subj}.merged.bam"
    output: 
        pep.config.pb_output_dir +"/downsample_bam/{subj}_{cov}X.bam"
    threads: 16
    resources :
        mem_mb=80000,
        runtime=1200
    envmodules: "sambamba", "samtools"
    shell: """
        sambamba view -h -t {threads} -s $(cat {input.fract}) -f bam --subsampling-seed=123 {input.bam} -o {output}
        samtools index {output}
    """

### Collect metrics on the downsampled data
rule bammetrics:
    input: pep.config.pb_output_dir +"/downsample_bam/{subj}_{cov}X.bam"
    output: pep.config.pb_output_dir +"/bammetrics/{subj}_{cov}.bammetrics.txt"
    params: 
        ref=pep.config.hg38_ref
    resources :
        threads=32,
        mem_mb= 120000,
        runtime="3d"
        #,
        #partition="gpu",
        #slurm="gres=gpu:v100x:2"
    benchmark:
        pep.config.pb_output_dir +"/benchmark/bammetrics/{subj}_{cov}.tsv"
    envmodules: "parabricks/4.0.0"
    shell: """
        pbrun bammetrics \
        --ref {params.ref} \
        --bam {input} \
        --out-metrics-file {output} \
        --num-threads {threads} 
    """

rule collectmultiplemetrics:
    input: pep.config.pb_output_dir + "/downsample_bam/{subj}_{cov}X.bam"
    output: pep.config.pb_output_dir +"/collectmultiplemetrics/{subj}_{cov}X/sequencingArtifact.pre_adapter_summary_metrics.txt"
    benchmark:
        pep.config.pb_output_dir +"/benchmark/collectmultiplemetrics/{subj}_{cov}.tsv"
    params: 
        ref=pep.config.hg38_ref
    resources :
        threads=32,
        mem_mb= 80000,
        runtime="2d",
        partition="gpu",
        slurm="gres=gpu:v100x:2"
    envmodules: "parabricks/4.0.0"
    shell: '''
        pbrun collectmultiplemetrics \
        --ref {params.ref} \
        --bam {input} \
        --out-qc-metrics-dir "$(dirname {output[0]})" \
        --gen-all-metrics 
    '''

### Now call GATK HC
rule gatkhc_pb:
    input:
        bam=pep.config.pb_output_dir +"/downsample_bam/{subj}_{cov}X.bam",
        ref=pep.config.hg38_ref,
        ref_dict=ref_dict
    output:
        gvcf=pep.config.pb_output_dir +"/gatkhc_pb/{subj}_{cov}.gatk.g.vcf"
    threads: 24
    benchmark:
        pep.config.pb_output_dir +"/benchmark/gatkhc_pb/{cov}/{subj}.tsv"
    resources: 
        mem_mb = 180000,
        runtime= "1d",
        partition="gpu",
        slurm="gres=gpu:v100x:4",
        tmpdir=pep.config.output_dir + "/TMP"
    envmodules: "parabricks/4.0.0"
    shell: """
        pbrun haplotypecaller \
            --gvcf \
            --ref {input.ref} \
            --in-bam {input.bam} \
            --out-variants {output.gvcf}        
    """

rule gatk_combine_gvcf:
    input: unpack(get_trio_hc_gvcf_pb)
    output: pep.config.pb_output_dir+"/gatk_combine_gvcf/{trio}_{cov}X.combine_gvcf.g.vcf.gz"
    threads: 16
    envmodules: "GATK/4.3.0.0"
    benchmark:
        pep.config.pb_output_dir + "/benchmark/gatk_combine_gvcf/{trio}_{cov}X.tsv"
    resources: 
        mem_mb = 40000,
        runtime= "10d"
    shell: """
        gatk CombineGVCFs \
            -V {input.child} \
            -V {input.mother} \
            -V {input.father} \
            -R {input.ref} \
            -O {output} 
    """

### note that output from pbrun genotypegvcf is gvcf (not in the gz format)
rule gatk_genotype_gvcf_pb:
    input: 
        gvcf=pep.config.pb_output_dir+"/gatk_combine_gvcf/{trio}_{cov}X.combine_gvcf.g.vcf.gz",
        ref=pep.config.hg38_ref
    output:
        vcf=pep.config.pb_output_dir+"/gatk_genotype_gvcf_pb/{trio}_{cov}X.genotype_gvcf.g.vcf",
        gz=pep.config.pb_output_dir+"/gatk_genotype_gvcf_pb/{trio}_{cov}X.genotype_gvcf.g.vcf.gz",
    threads: 16
    envmodules: "parabricks/4.0.0", "bcftools"
    benchmark:
        pep.config.pb_output_dir + "/benchmark/gatk_genotype_gvcf_pb/{trio}_{cov}X.tsv"
    resources: 
        mem_mb = 80000,
        runtime= "1d",
        partition="gpu",
        slurm="gres=gpu:v100x:4",
        tmpdir=pep.config.output_dir + "/TMP"
    shell: """
        pbrun genotypegvcf \
            --in-gvcf {input.gvcf} \
            --ref {input.ref} \
            --out-vcf {output.vcf} 
        bgzip -@ {threads} -c {output.vcf}> {output.gz} && \
        tabix {output.gz}
    """



# CalculateGenotypePosteriors
rule gatk_cgp:
    input: 
        gvcf=pep.config.pb_output_dir+"/gatk_genotype_gvcf_pb/{trio}_{cov}X.genotype_gvcf.g.vcf.gz",
        ped="pep/{trio}.ped"
    output: pep.config.pb_output_dir+"/gatk_cgp/{trio}_{cov}X.cgp.g.vcf.gz"
    threads: 16
    envmodules: "GATK/4.3.0.0"
    benchmark:
        pep.config.pb_output_dir + "/benchmark/gatk_cgp/{trio}_{cov}X.tsv"
    resources: 
        mem_mb = 40000,
        runtime= "10d"
    shell: """
        gatk CalculateGenotypePosteriors \
            -V {input.gvcf} \
            -ped {input.ped} --skip-population-priors \
            -O {output} 
    """

### Call DV
rule deepvariant_pb:
    input:
        bam=pep.config.pb_output_dir +"/downsample_bam/{subj}_{cov}X.bam",
        ref=pep.config.hg38_ref
    output:
        gvcf=pep.config.pb_output_dir +"/deepvariant_pb/{subj}_{cov}X.deepvariant.g.vcf"
    threads: 48
    benchmark:
        pep.config.pb_output_dir +"/benchmark/deepvariant_pb/{cov}/{subj}.tsv"
    envmodules: "parabricks/4.0.0", "bcftools"
    resources: 
        mem_mb = 180000,
        runtime= "1d",
        partition="gpu",
        slurm="gres=gpu:v100x:4",
        tmpdir=pep.config.output_dir + "/TMP"
    shell: """
        pbrun deepvariant \
        --gvcf  \
        --ref {input.ref} \
        --in-bam {input.bam} \
        --out-variants {output.gvcf} 
    """

rule vcf_gzip: 
    input: vcf=pep.config.pb_output_dir +"/deepvariant_pb/{subj}_{cov}X.deepvariant.g.vcf"
    output: 
        vcf=pep.config.pb_output_dir +"/deepvariant_pb/{subj}_{cov}X.deepvariant.g.vcf.gz",
        tbi=pep.config.pb_output_dir +"/deepvariant_pb/{subj}_{cov}X.deepvariant.g.vcf.gz.tbi"
    threads: 8
    envmodules: "bcftools"
    shell: """
        bgzip -@ {threads} -c {input.vcf}> {output.vcf} && \
        tabix {output.vcf}
    """

### Use gatk rule again to combine vcf from deep variatn rather than to use glnexus
### gvcf from DV cannot be recognized properly by gatk

# use rule gatk_combine_gvcf as gatk_combine_DVgvcf with:
#     input: 
#         unpack(get_trio_hc_gvcf_dv)
#     output: 
#         pep.config.pb_output_dir+"/gatk_combine_DVgvcf/{trio}_{cov}X.combine_gvcf.g.vcf.gz"
#     benchmark:
#         pep.config.pb_output_dir + "/benchmark/gatk_combine_DVgvcf/{trio}_{cov}X.tsv"

# use rule gatk_genotype_gvcf_pb as gatk_genotype_gvcf_dv with:
#     input: 
#         gvcf=pep.config.pb_output_dir+"/gatk_combine_DVgvcf/{trio}_{cov}X.combine_gvcf.g.vcf.gz",
#         ref=pep.config.hg38_ref
#     output:
#         pep.config.pb_output_dir+"/gatk_genotype_gvcf_dv/{trio}_{cov}X.genotype_gvcf.g.vcf.gz"
#     benchmark:
#         pep.config.pb_output_dir + "/benchmark/gatk_genotype_gvcf_dv/{trio}_{cov}X.tsv"

# use rule gatk_cgp as gatk_cgp_dv with:
#     input: 
#         gvcf=pep.config.pb_output_dir+"/gatk_genotype_gvcf_dv/{trio}_{cov}X.genotype_gvcf.g.vcf.gz",
#         ped="pep/{trio}.ped"
#     output: 
#         pep.config.pb_output_dir+"/gatk_cgp_dv/{trio}_{cov}X.cgp.g.vcf.gz"
#     benchmark:
#         pep.config.pb_output_dir + "/benchmark/gatk_cgp_dv/{trio}_{cov}X.tsv"
    
# vcf=pep.config.pb_output_dir +"/deepvariant_pb/{subj}_{cov}X.deepvariant.g.vcf.gz"
rule glnexus_dv: 
    input:
        gvcf=lambda w: expand(pep.config.pb_output_dir +"/deepvariant_pb/{subj}_{{cov}}X.deepvariant.g.vcf.gz", subj=list(trio_dict[w.trio].values())),
        tbi=lambda w: expand(pep.config.pb_output_dir +"/deepvariant_pb/{subj}_{{cov}}X.deepvariant.g.vcf.gz.tbi", subj=list(trio_dict[w.trio].values())),
        ref=pep.config.hg38_ref
    output:
        vcf = pep.config.pb_output_dir +"/glnexus/{trio}_{cov}X.dv_combined.vcf.gz"
    threads: 8
    benchmark:
        pep.config.pb_output_dir +"/benchmark/glnexus_dv/dv_{trio}_{cov}X.tsv"
    resources: 
        mem_mb = 100*1000,
        runtime= "1d"
    envmodules: "glnexus", "bcftools"
    params: 
        tempdir=temp(directory(pep.config.pb_output_dir +"/glnexus/GLnexus.DB_{}")).format(uuid.uuid4()) 
    shell: """
        glnexus_cli -t {threads} --config DeepVariantWGS --dir {params.tempdir} {input.gvcf} |  bcftools norm -f {input.ref} -m - -O z -o {output} 
        rm -fr {params.tempdir}
    """

rule call_dnm: 
    input: 
        vcf = pep.config.pb_output_dir +"/glnexus/{trio}_{cov}X.dv_combined.vcf.gz",
        ped="ref/AJtrio.ped"
    output:
        vcf= pep.config.pb_output_dir +"/slivar/DV_{trio}_{cov}X.dnm.vcf"
    benchmark:
        pep.config.pb_output_dir +"/benchmark/slivar/DV_{trio}_{cov}X.tsv"
    resources: 
        mem_mb = 20*1000,
        runtime= "1d"
    conda:
        "workflow/envs/slivar.yaml"
    shell: """
        slivar expr  \
            --vcf {input.vcf} \
            --ped  {input.ped} \
            --pass-only \
            --out-vcf {output} \
            --trio "denovo:kid.het && mom.hom_ref && dad.hom_ref \
                    && kid.AB > 0.25 && kid.AB < 0.75 \
                    && (mom.AD[1] + dad.AD[1]) <= 3 \
                    && kid.GQ >= 10 && mom.GQ >= 10 && dad.GQ >= 10 \
                    && kid.DP >= 10 && mom.DP >= 10 && dad.DP >= 10"
    """



# gatk_hc_happy.output.extended.csv
# gatk_hc_happy.output.metrics.json.gz
# gatk_hc_happy.output.roc.all.csv.gz
# gatk_hc_happy.output.roc.Locations.INDEL.csv.gz
# gatk_hc_happy.output.roc.Locations.INDEL.PASS.csv.gz
# gatk_hc_happy.output.roc.Locations.SNP.csv.gz
# gatk_hc_happy.output.roc.Locations.SNP.PASS.csv.gz
# gatk_hc_happy.output.runinfo.json
# gatk_hc_happy.output.summary.csv
# gatk_hc_happy.output.vcf.gz
# gatk_hc_happy.output.vcf.gz.tbi
# rule giab_happy:
#     input: 
#         query=pep.config.pb_output_dir +"/dnm/{trio}_{cov}X.dnm.vcf.gz",
#         truth=pep.config.truth_vcf,
#         truth_regions=pep.config.truth_bed,
#         genome = pep.config.hg38_ref
#     output:
#         multiext(pep.config.pb_output_dir +"/hap.py/{trio}_{cov}X.happy",
#         ".runinfo.json",".vcf.gz",".summary.csv",
#                 ".extended.csv",".metrics.json.gz",".roc.all.csv.gz",
#                 ".roc.Locations.INDEL.csv.gz",".roc.Locations.INDEL.PASS.csv.gz",
#                 ".roc.Locations.SNP.csv.gz",".roc.tsv")
#     resources: 
#         mem_mb = 80000,
#         runtime= "10h",
#         # tmpdir="/gpfs/gsfs12/users/zhuw10/TMP"
#         tmpdir=pep.config.output_dir + "/TMP"
#     params: 
#         engine="vcfeval",
#         prefix=lambda wc, input, output: output[0].split('.')[0],
#         ## parameters such as -L to left-align variants
#         extra="--verbose"
#     benchmark:
#         pep.config.pb_output_dir +"/benchmark/giab_happy/{trio}_{cov}X.tsv"
#     threads: 4
#     wrapper: "v1.23.5/bio/hap.py/hap.py"



### Call dnm from gatk
use rule  call_dnm as call_dnm_gatk with:
    input: 
        vcf=pep.config.pb_output_dir+"/gatk_cgp/{trio}_{cov}X.cgp.g.vcf.gz",
        ped="ref/AJtrio.ped"
    output: 
       vcf= pep.config.pb_output_dir +"/slivar/GATK_{trio}_{cov}X.dnm.vcf"

rule extract_child_dnm:
    input: vcf= pep.config.pb_output_dir +"/slivar/{caller}_{trio}_{cov}X.dnm.vcf"
    output: pep.config.pb_output_dir +"/dnm/{caller}_{trio}_{cov}X.dnm.vcf.gz"
    params: child_id=lambda w: trio_dict[w.trio]["child"]
    envmodules: "bcftools"
    resources: 
        mem_mb = 20*1000,
        runtime= "4h"
    benchmark:
        pep.config.pb_output_dir +"/benchmark/extract_child_dnm/{caller}_{trio}_{cov}X.tsv"
    shell: """
        bcftools view -s {params.child_id} {input.vcf} -o {output} -O z
    
    """

rule giab_happy:
    input: 
        in_vcf=pep.config.pb_output_dir +"/dnm/{caller}_{trio}_{cov}X.dnm.vcf.gz",
        truth_vcf=pep.config.truth_vcf,
        truth_bed=pep.config.truth_bed,
        ref = pep.config.hg38_ref
    output:
        prefix=pep.config.pb_output_dir +"/hap.py/{caller}_{trio}_{cov}X.happy",
        summary=pep.config.pb_output_dir +"/hap.py/{caller}_{trio}_{cov}X.happy.extended.csv"
    resources: 
        threads = 4,
        mem_mb = 80000,
        runtime= "10h",
        # tmpdir="/gpfs/gsfs12/users/zhuw10/TMP"
        tmpdir=pep.config.output_dir + "/TMP"
    envmodules: "hap.py", "rtg-tools", "bcftools"
    benchmark:
        pep.config.pb_output_dir +"/benchmark/giab_happy/{caller}_{trio}_{cov}X.tsv"
    shell: """
        hap.py {input.truth_vcf} \
            {input.in_vcf} \
            -f  {input.truth_bed} \
            -r {input.ref} \
            -o {output.prefix} \
            --engine=vcfeval --threads {threads}  --fixchr --bcftools-norm --verbose
    """